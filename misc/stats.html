<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Mount Stats</title>
    <style>
        table {
            border-collapse: collapse;
            width: 100%;
        }

        th,
        td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: left;
        }

        th {
            cursor: pointer;
        }

        th.sort-asc::after {
            content: " \25B2";
        }

        th.sort-desc::after {
            content: " \25BC";
        }

        select {
            margin: 10px 5px 10px 0;
        }
    </style>
    <script src="mounts_json.js"></script>
    <script src="mount_data.js"></script>
</head>

<body>
    <h2>Mount stats</h2>

    <label for="mountEstimate">Estimated Mounts Collected:</label>
    <select id="mountEstimate">
        <option value="all">Show All</option>
        <option value="10">Up to 10</option>
        <option value="50">Up to 50</option>
        <option value="100">Up to 100</option>
        <option value="200">Up to 200</option>
        <option value="300">Up to 300</option>
        <option value="400">Up to 400</option>
        <option value="1000">Up to 1000</option>
        <option value="1500">Up to 1500</option>
    </select>

    <label for="preferenceLevel">Preference Level:</label>
    <select id="preferenceLevel">
        <option value="normal">Normal</option>
        <option value="more">More</option>
        <option value="most">Most</option>
        <option value="all">All</option>
    </select>

    <table id="statsTable">
        <thead>
            <tr>
                <th data-column="specId">Spec ID</th>
                <th data-column="specName">Spec Name</th>
                <th data-column="raceName">Race Name</th>
                <th data-column="mountCount">Mount Count</th>
            </tr>
        </thead>
        <tbody id="statsBody"></tbody>
    </table>

    <script>

        const sizeMountSets = {
            small: ["kite", "emu", "fish", "rat", "crocodile", "insect", "cat", "bat", "dinosaur", "wolf", "stag", "horse"],
            normal: ["crocodile", "insect", "cat", "bat", "dinosaur", "wolf", "stag", "horse", "bear", "mechanical", "spider", "gryphon", "snail", "bird"],
            large: ["bear", "mechanical", "spider", "gryphon", "snail", "bird", "elemental", "gargoyle", "dragon", "serpent", "mammoth", "kodo"]
        };

        function getRacePreference(race, level) {
            const info = raceMountPreferencesCombined[race];
            if (!info) return [];

            const standard = info.standard || [];
            const extra = info.extra || [];
            const sizeExtras = sizeMountSets[info.size] || [];

            if (level === "normal") return standard;
            if (level === "more") return [...new Set([...standard, ...extra])];
            if (level === "most") return [...new Set([...standard, ...extra, ...sizeExtras])];
            if (level === "all") return Object.values(sizeMountSets).flat();

            return standard;
        }

        document.addEventListener("DOMContentLoaded", () => {
            const races = Object.keys(raceMountPreferencesCombined);
            const specs = Object.keys(specMountTypes).map(Number);
            let fullData = [];
            let currentSort = { column: null, direction: "asc" };

            function mountMatchesFilters(mount, specId, race, level) {
                const types = specMountTypes[specId];
                const looks = looksForSpecs[specId];
                const colors = specColorThemes[specId];

                const racePrefs = getRacePreference(race, level);
                if (!types || !racePrefs) return false;
                return types.includes(mount.skeleton_type) ||
                    racePrefs.includes(mount.skeleton_type) &&
                    looks.includes(mount.looks) &&
                    (colors.includes(mount.color) || colors.includes(mount.secondary_color));
            }

            function generateStatsData(level) {
                const rows = [];
                for (const specId of specs) {
                    const className = specClasses[specId];
                    for (const race of races) {
                        if (!legalCombos[race] || !legalCombos[race].includes(className)) continue;
                        const matchedMounts = mounts.filter(m => mountMatchesFilters(m, specId, race, level));
                        rows.push({
                            specId,
                            specName: specNames[specId] || "Unknown",
                            raceName: raceNames[race] || race,
                            matchedMounts,
                            rawCount: matchedMounts.length,
                            mountCount: matchedMounts.length
                        });
                    }
                }
                return rows;
            }

            function applyFiltersAndRender() {
                const estimate = document.getElementById("mountEstimate").value;
                const level = document.getElementById("preferenceLevel").value;
                fullData = generateStatsData(level);

                let data = [...fullData];
                if (estimate !== "all") {
                    const est = parseInt(estimate);
                    const uniqueMounts = new Set(mounts.map(m => m.id));
                    const totalGameMounts = uniqueMounts.size;
                    const ratio = est / totalGameMounts;

                    data.forEach(row => {
                        row.mountCount = Math.round(row.rawCount * ratio);
                    });
                } else {
                    data.forEach(row => row.mountCount = row.rawCount);
                }

                if (currentSort.column) {
                    const col = currentSort.column;
                    const dir = currentSort.direction;
                    data.sort((a, b) => {
                        if (a[col] < b[col]) return dir === "asc" ? -1 : 1;
                        if (a[col] > b[col]) return dir === "asc" ? 1 : -1;
                        return 0;
                    });
                }

                renderTable(data);
            }

            function renderTable(data) {
                const tbody = document.getElementById("statsBody");
                tbody.innerHTML = "";
                const fragment = document.createDocumentFragment();
                for (const row of data) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `<td>${row.specId}</td><td>${row.specName}</td><td>${row.raceName}</td><td>${row.mountCount}</td>`;
                    fragment.appendChild(tr);
                }
                tbody.appendChild(fragment);
            }

            document.querySelectorAll("th").forEach(th => {
                th.addEventListener("click", () => {
                    const col = th.getAttribute("data-column");
                    const dir = (currentSort.column === col && currentSort.direction === "asc") ? "desc" : "asc";
                    currentSort = { column: col, direction: dir };

                    document.querySelectorAll("th").forEach(th => th.classList.remove("sort-asc", "sort-desc"));
                    th.classList.add(dir === "asc" ? "sort-asc" : "sort-desc");

                    applyFiltersAndRender();
                });
            });

            document.getElementById("mountEstimate").addEventListener("change", applyFiltersAndRender);
            document.getElementById("preferenceLevel").addEventListener("change", applyFiltersAndRender);

            fullData = generateStatsData("normal");
            applyFiltersAndRender();
        });
    </script>
</body>

</html>